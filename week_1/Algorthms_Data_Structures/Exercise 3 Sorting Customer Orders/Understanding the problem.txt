Bubble Sort:

Algorithm: Repeatedly compares adjacent elements and swaps them if they are in the wrong order. This process continues until the list is sorted.
Time Complexity: O(n²) for average and worst cases. It’s inefficient for large datasets due to its quadratic time complexity.
Use Case: Simple to implement but not suitable for large lists.
Insertion Sort:

Algorithm: Builds the final sorted array one item at a time. It picks elements from the unsorted part and inserts them into the correct position in the sorted part.
Time Complexity: O(n²) for average and worst cases. Better than Bubble Sort in practice but still quadratic.
Use Case: Suitable for small or nearly sorted datasets.
Quick Sort:

Algorithm: Divides the dataset into smaller sub-arrays based on a pivot element. The sub-arrays are then sorted independently. The process continues recursively.
Time Complexity: O(n log n) on average, O(n²) in the worst case if the pivot choices are poor. It is usually faster in practice due to good average-case performance.
Use Case: Efficient for large datasets due to its logarithmic time complexity.
Merge Sort:

Algorithm: Divides the dataset into halves recursively until each sub-array contains a single element. It then merges these sub-arrays in sorted order.
Time Complexity: O(n log n) for both average and worst cases. Consistent performance and stable.
Use Case: Suitable for large datasets and provides consistent performance but requires additional space for merging.